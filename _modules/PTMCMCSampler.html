<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PTMCMCSampler &mdash; PTMCMCSampler  documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="PTMCMCSampler  documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">PTMCMCSampler  documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for PTMCMCSampler</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="kn">as</span> <span class="nn">ss</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">nompi4py</span> <span class="k">as</span> <span class="n">MPI</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;WARNING: no mpi4py installed. Parallel jobs will not run correctly&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">acor</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Do not have acor package&#39;</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="PTSampler"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler">[docs]</a><span class="k">class</span> <span class="nc">PTSampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parallel Tempering Markov Chain Monte-Carlo (PTMCMC) sampler.</span>
<span class="sd">    This implementation uses an adaptive jump proposal scheme</span>
<span class="sd">    by default using both standard and single component Adaptive</span>
<span class="sd">    Metropolis (AM) and Differential Evolution (DE) jumps.</span>

<span class="sd">    This implementation also makes use of MPI (mpi4py) to run</span>
<span class="sd">    the parallel chains.</span>

<span class="sd">    Along with the AM and DE jumps, the user can add custom</span>
<span class="sd">    jump proposals with the ``addProposalToCycle`` fuction.</span>

<span class="sd">    :param ndim: number of dimensions in problem</span>
<span class="sd">    :param logl: log-likelihood function</span>
<span class="sd">    :param logp: log prior function (must be normalized for evidence evaluation)</span>
<span class="sd">    :param cov: Initial covariance matrix of model parameters for jump proposals</span>
<span class="sd">    :param covinds: Indices of parameters for which to perform adaptive jumps</span>
<span class="sd">    :param loglargs:</span>
<span class="sd">        any additional arguments (apart from the parameter vector)</span>
<span class="sd">        for log likelihood</span>
<span class="sd">    :param loglkwargs:</span>
<span class="sd">        any additional keyword arguments (apart from the parameter vector)</span>
<span class="sd">        for log likelihood</span>
<span class="sd">    :param logpargs:</span>
<span class="sd">        any additional arguments (apart from the parameter vector) for</span>
<span class="sd">        log like prior</span>
<span class="sd">    :param logpkwargs:</span>
<span class="sd">        any additional keyword arguments (apart from the parameter vector)</span>
<span class="sd">        for log prior</span>
<span class="sd">    :param outDir: Full path to output directory for chain files (default = ./chains)</span>
<span class="sd">    :param verbose: Update current run-status to the screen (default=True)</span>
<span class="sd">    :param resume: Resume from a previous chain (still in testing so beware) (default=False)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">logl</span><span class="p">,</span> <span class="n">logp</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loglargs</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">loglkwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">logpargs</span><span class="o">=</span><span class="p">[],</span> <span class="n">logpkwargs</span><span class="o">=</span><span class="p">{},</span>
                 <span class="n">comm</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">outDir</span><span class="o">=</span><span class="s">&#39;./chains&#39;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="c"># MPI initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">ndim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logl</span> <span class="o">=</span> <span class="n">_function_wrapper</span><span class="p">(</span><span class="n">logl</span><span class="p">,</span> <span class="n">loglargs</span><span class="p">,</span> <span class="n">loglkwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp</span> <span class="o">=</span> <span class="n">_function_wrapper</span><span class="p">(</span><span class="n">logp</span><span class="p">,</span> <span class="n">logpargs</span><span class="p">,</span> <span class="n">logpkwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outDir</span> <span class="o">=</span> <span class="n">outDir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">resume</span>

        <span class="c"># setup output file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outDir</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outDir</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c"># find indices for which to perform adaptive jumps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span>
        <span class="k">if</span> <span class="n">groups</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>

        <span class="c"># set up covariance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>

        <span class="c"># do svd on parameter groups</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">):</span>
            <span class="n">covgroup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                    <span class="n">covgroup</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">group</span><span class="p">[</span><span class="n">jj</span><span class="p">]]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">covgroup</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>

        <span class="c"># initialize proposal cycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># indicator for auxilary jumps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="PTSampler.initialize"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Niter</span><span class="p">,</span> <span class="n">ladder</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Tskip</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                   <span class="n">isave</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">covUpdate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">KDEupdate</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">SCAMweight</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                   <span class="n">AMweight</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">DEweight</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">KDEweight</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                   <span class="n">maxIter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">i0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">neff</span><span class="o">=</span><span class="mi">100000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize MCMC quantities</span>

<span class="sd">        :param maxIter: maximum number of iterations</span>
<span class="sd">        :praam Tmin: minimum temperature to use in temperature ladder</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># get maximum number of iteration</span>
        <span class="k">if</span> <span class="n">maxIter</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">maxIter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Niter</span>
        <span class="k">elif</span> <span class="n">maxIter</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">maxIter</span> <span class="o">=</span> <span class="n">Niter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ladder</span> <span class="o">=</span> <span class="n">ladder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covUpdate</span> <span class="o">=</span> <span class="n">covUpdate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KDEupdate</span> <span class="o">=</span> <span class="n">KDEupdate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SCAMweight</span> <span class="o">=</span> <span class="n">SCAMweight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AMweight</span> <span class="o">=</span> <span class="n">AMweight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DEweight</span> <span class="o">=</span> <span class="n">DEweight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KDEweight</span> <span class="o">=</span> <span class="n">KDEweight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">burn</span> <span class="o">=</span> <span class="n">burn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tskip</span> <span class="o">=</span> <span class="n">Tskip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thin</span> <span class="o">=</span> <span class="n">thin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isave</span> <span class="o">=</span> <span class="n">isave</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Niter</span> <span class="o">=</span> <span class="n">Niter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neff</span> <span class="o">=</span> <span class="n">neff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxIter</span> <span class="o">/</span> <span class="n">thin</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lnprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lnlike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">naccepted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swapProposed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nswap_accepted</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># set up covariance matrix and DE buffers</span>
        <span class="c"># TODO: better way of allocating this to save memory</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Niter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="c"># ##### setup default jump proposal distributions ##### #</span>

        <span class="c"># add SCAM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addProposalToCycle</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covarianceJumpProposalSCAM</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SCAMweight</span><span class="p">)</span>

        <span class="c"># add AM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addProposalToCycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covarianceJumpProposalAM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">AMweight</span><span class="p">)</span>

        <span class="c"># randomize cycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomizeProposalCycle</span><span class="p">()</span>

        <span class="c"># setup default temperature ladder</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ladder</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ladder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperatureLadder</span><span class="p">(</span><span class="n">Tmin</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">=</span><span class="n">Tmax</span><span class="p">)</span>

        <span class="c"># temperature for current chain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ladder</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span><span class="p">]</span>

        <span class="c"># set up output file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outDir</span> <span class="o">+</span> <span class="s">&#39;/chain_{0}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resume</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;Resuming run from chain file {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;WARNING: Cant read in file. Removing last line.&#39;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;sed -ie </span><span class="se">\&#39;</span><span class="s">$d</span><span class="se">\&#39;</span><span class="s"> {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PTSampler.updateChains"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.updateChains">[docs]</a>    <span class="k">def</span> <span class="nf">updateChains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update chains after jump proposals</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># update buffer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span><span class="p">[</span><span class="nb">iter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p0</span>

        <span class="c"># put results into arrays</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">thin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">iter</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">thin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chain</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lnlike</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnlike0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lnprob</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnprob0</span>

        <span class="c"># write to file</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">isave</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_writeToFile</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>

            <span class="c"># write output covariance matrix</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outDir</span> <span class="o">+</span> <span class="s">&#39;/cov.npy&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Finished </span><span class="si">%2.2f</span><span class="s"> percent in </span><span class="si">%f</span><span class="s"> s&#39;</span> <span class="o">+</span>
                                 <span class="s">&#39;Acceptance rate = </span><span class="si">%g</span><span class="s">&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Niter</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">naccepted</span> <span class="o">/</span> <span class="nb">iter</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PTSampler.sample"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">Niter</span><span class="p">,</span> <span class="n">ladder</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Tskip</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
               <span class="n">isave</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">covUpdate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">KDEupdate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">SCAMweight</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
               <span class="n">AMweight</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">DEweight</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">KDEweight</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
               <span class="n">maxIter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">i0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">neff</span><span class="o">=</span><span class="mi">100000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to carry out PTMCMC sampling.</span>

<span class="sd">        :param p0: Initial parameter vector</span>
<span class="sd">        :param self.Niter: Number of iterations to use for T = 1 chain</span>
<span class="sd">        :param ladder: User defined temperature ladder</span>
<span class="sd">        :param Tmin: Minimum temperature in ladder (default=1)</span>
<span class="sd">        :param Tmax: Maximum temperature in ladder (default=None)</span>
<span class="sd">        :param Tskip: Number of steps between proposed temperature swaps (default=100)</span>
<span class="sd">        :param isave: Number of iterations before writing to file (default=1000)</span>
<span class="sd">        :param covUpdate: Number of iterations between AM covariance updates (default=1000)</span>
<span class="sd">        :param KDEUpdate: Number of iterations between KDE updates (default=1000)</span>
<span class="sd">        :param SCAMweight: Weight of SCAM jumps in overall jump cycle (default=20)</span>
<span class="sd">        :param AMweight: Weight of AM jumps in overall jump cycle (default=20)</span>
<span class="sd">        :param DEweight: Weight of DE jumps in overall jump cycle (default=20)</span>
<span class="sd">        :param KDEweight: Weight of KDE jumps in overall jump cycle (default=100)</span>
<span class="sd">        :param burn: Burn in time (DE jumps added after this iteration) (default=10000)</span>
<span class="sd">        :param maxIter: Maximum number of iterations for high temperature chains</span>
<span class="sd">                        (default=2*self.Niter)</span>
<span class="sd">        :param self.thin: Save every self.thin MCMC samples</span>
<span class="sd">        :param i0: Iteration to start MCMC (if i0 !=0, do not re-initialize)</span>
<span class="sd">        :param neff: Number of effective samples to collect before terminating</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># get maximum number of iteration</span>
        <span class="k">if</span> <span class="n">maxIter</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">maxIter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Niter</span>
        <span class="k">elif</span> <span class="n">maxIter</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">maxIter</span> <span class="o">=</span> <span class="n">Niter</span>

        <span class="c"># set up arrays to store lnprob, lnlike and chain</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxIter</span> <span class="o">/</span> <span class="n">thin</span><span class="p">)</span>

        <span class="c"># if picking up from previous run, don&#39;t re-initialize</span>
        <span class="k">if</span> <span class="n">i0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">Niter</span><span class="p">,</span> <span class="n">ladder</span><span class="o">=</span><span class="n">ladder</span><span class="p">,</span> <span class="n">Tmin</span><span class="o">=</span><span class="n">Tmin</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">=</span><span class="n">Tmax</span><span class="p">,</span>
                            <span class="n">Tskip</span><span class="o">=</span><span class="n">Tskip</span><span class="p">,</span> <span class="n">isave</span><span class="o">=</span><span class="n">isave</span><span class="p">,</span> <span class="n">covUpdate</span><span class="o">=</span><span class="n">covUpdate</span><span class="p">,</span>
                            <span class="n">KDEupdate</span><span class="o">=</span><span class="n">KDEupdate</span><span class="p">,</span> <span class="n">SCAMweight</span><span class="o">=</span><span class="n">SCAMweight</span><span class="p">,</span>
                            <span class="n">AMweight</span><span class="o">=</span><span class="n">AMweight</span><span class="p">,</span> <span class="n">DEweight</span><span class="o">=</span><span class="n">DEweight</span><span class="p">,</span>
                            <span class="n">KDEweight</span><span class="o">=</span><span class="n">KDEweight</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="n">burn</span><span class="p">,</span>
                            <span class="n">maxIter</span><span class="o">=</span><span class="n">maxIter</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">i0</span><span class="o">=</span><span class="n">i0</span><span class="p">,</span>
                            <span class="n">neff</span><span class="o">=</span><span class="n">neff</span><span class="p">)</span>

        <span class="c">### compute lnprob for initial point in chain ###</span>

        <span class="c"># if resuming, just start with first point in chain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resume</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># compute prior</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">lp</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>

                <span class="n">lnprob0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">lnlike0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">lnlike0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logl</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
                <span class="n">lnprob0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">*</span> <span class="n">lnlike0</span> <span class="o">+</span> <span class="n">lp</span>

        <span class="c"># record first values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updateChains</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="n">i0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c"># start iterations</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="n">i0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">runComplete</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">Neff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">runComplete</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># call PTMCMCOneStep</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PTMCMCOneStep</span><span class="p">(</span>
                <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>

            <span class="c"># compute effective number of samples</span>
            <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Neff</span> <span class="o">=</span> <span class="nb">iter</span> <span class="o">/</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">acor</span><span class="o">.</span><span class="n">acor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">burn</span><span class="p">:(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ii</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span>
                    <span class="c"># print &#39;\n {0} effective samples&#39;.format(Neff)</span>
                <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                    <span class="n">Neff</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">pass</span>

            <span class="c"># stop if reached maximum number of iterations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Niter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Run Complete&#39;</span>
                <span class="n">runComplete</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c"># stop if reached effective number of samples</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">neff</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Run Complete with {0} effective samples&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Neff</span><span class="p">))</span>
                <span class="n">runComplete</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">runComplete</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchain</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">runComplete</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">jj</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">55</span><span class="p">)</span>

            <span class="c"># check for other chains</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">runComplete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Iprobe</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">55</span><span class="p">)</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.000001</span><span class="p">)</span>  <span class="c"># trick to get around</span>
</div>
<div class="viewcode-block" id="PTSampler.PTMCMCOneStep"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.PTMCMCOneStep">[docs]</a>    <span class="k">def</span> <span class="nf">PTMCMCOneStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to carry out PTMCMC sampling.</span>

<span class="sd">        :param p0: Initial parameter vector</span>
<span class="sd">        :param lnlike0: Initial log-likelihood value</span>
<span class="sd">        :param lnprob0: Initial log probability value</span>
<span class="sd">        :param iter: iteration number</span>

<span class="sd">        :returns: next value of parameter vector after one MCMC step</span>
<span class="sd">        :returns: next value of likelihood after one MCMC step</span>
<span class="sd">        :returns: next value of posterior after one MCMC step</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># update covariance matrix</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">covUpdate</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span>
                                                 <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateRecursive</span><span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covUpdate</span><span class="p">)</span>

            <span class="c"># broadcast to other chains</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span> <span class="k">for</span> <span class="n">rank</span>
             <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c"># check for sent covariance matrix from T = 0 chain</span>
        <span class="n">getCovariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Iprobe</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.000001</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">getCovariance</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">):</span>
                <span class="n">covgroup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                        <span class="n">covgroup</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">group</span><span class="p">[</span><span class="n">jj</span><span class="p">]]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">covgroup</span><span class="p">)</span>
            <span class="n">getCovariance</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># update KDE buffer after burn in</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">KDEupdate</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">burn</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">KDEupdate</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="bp">self</span><span class="o">.</span><span class="n">KDEweight</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateKDE</span><span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">KDEupdate</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addProposalToCycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">KDEJumpProposal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">KDEweight</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">randomizeProposalCycle</span><span class="p">()</span>

        <span class="c"># update DE buffer</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateDEbuffer</span><span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn</span><span class="p">)</span>

            <span class="c"># broadcast to other chains</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">222</span><span class="p">)</span> <span class="k">for</span> <span class="n">rank</span>
             <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c"># check for sent DE buffer from T = 0 chain</span>
        <span class="n">getDEbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Iprobe</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">222</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.000001</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">getDEbuf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">222</span><span class="p">)</span>

            <span class="c"># randomize cycle</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEJump</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addProposalToCycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEJump</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEweight</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">randomizeProposalCycle</span><span class="p">()</span>

            <span class="c"># reset</span>
            <span class="n">getDEbuf</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># after burn in, add DE jumps</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;Adding DE jump with weight {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEweight</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addProposalToCycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEJump</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEweight</span><span class="p">)</span>

            <span class="c"># randomize cycle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">randomizeProposalCycle</span><span class="p">()</span>

        <span class="c">### jump proposal ###</span>

        <span class="c"># if resuming, just use previous chain points</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resume</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumeLength</span><span class="p">:</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="nb">iter</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="nb">iter</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="nb">iter</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>

            <span class="c"># update acceptance counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">naccepted</span> <span class="o">=</span> <span class="nb">iter</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">resumechain</span><span class="p">[</span><span class="nb">iter</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">accepted</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">qxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>

            <span class="c"># compute prior and likelihood</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">lp</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>

                <span class="n">newlnprob</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">newlnlike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logl</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">newlnprob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">*</span> <span class="n">newlnlike</span> <span class="o">+</span> <span class="n">lp</span>

            <span class="c"># hastings step</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">newlnprob</span> <span class="o">-</span> <span class="n">lnprob0</span> <span class="o">+</span> <span class="n">qxy</span>
            <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()):</span>

                <span class="c"># accept jump</span>
                <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">newlnlike</span><span class="p">,</span> <span class="n">newlnprob</span>

                <span class="c"># update acceptance counter</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">naccepted</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">accepted</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c"># temperature swap</span>
        <span class="n">swapReturn</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PTswap</span><span class="p">(</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>

        <span class="c"># check return value</span>
        <span class="k">if</span> <span class="n">swapReturn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swapProposed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">swapReturn</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nswap_accepted</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">updateChains</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span>
</div>
<div class="viewcode-block" id="PTSampler.PTswap"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.PTswap">[docs]</a>    <span class="k">def</span> <span class="nf">PTswap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do parallel tempering swap.</span>

<span class="sd">        :param p0: current parameter vector</span>
<span class="sd">        :param lnlike0: current log-likelihood</span>
<span class="sd">        :param lnprob0: current log posterior value</span>
<span class="sd">        :param iter: current iteration number</span>

<span class="sd">        :returns:</span>
<span class="sd">            0 = no swap proposed, 1 = swap proposed and rejected,</span>
<span class="sd">            2 = swap proposed and accepted</span>

<span class="sd">        :returns: new parameter vector</span>
<span class="sd">        :returns: new log-likelihood</span>
<span class="sd">        :returns: new log posterior value</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># initialize variables</span>
        <span class="n">readyToSwap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">swapAccepted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">swapProposed</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># if Tskip is reached, block until next chain in ladder is ready for</span>
        <span class="c"># swap proposal</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tskip</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">swapProposed</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c"># send current likelihood for swap proposal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">lnlike0</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c"># determine if swap was accepted</span>
            <span class="n">swapAccepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c"># perform swap</span>
            <span class="k">if</span> <span class="n">swapAccepted</span><span class="p">:</span>

                <span class="c"># exchange likelihood</span>
                <span class="n">lnlike0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c"># exchange parameters</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c"># calculate new posterior values</span>
                <span class="n">lnprob0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">*</span> <span class="n">lnlike0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>

        <span class="c"># check if next lowest temperature is ready to swap</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">readyToSwap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Iprobe</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c"># trick to get around processor using 100% cpu while waiting</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.000001</span><span class="p">)</span>

            <span class="c"># hotter chain decides acceptance</span>
            <span class="k">if</span> <span class="n">readyToSwap</span><span class="p">:</span>
                <span class="n">newlnlike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c"># determine if swap is accepted and tell other chain</span>
                <span class="n">logChainSwap</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ladder</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
                                <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ladder</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span><span class="p">])</span>
                                <span class="o">*</span> <span class="p">(</span><span class="n">lnlike0</span> <span class="o">-</span> <span class="n">newlnlike</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">logChainSwap</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()):</span>
                    <span class="n">swapAccepted</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">swapAccepted</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c"># send out result</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">swapAccepted</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c"># perform swap</span>
                <span class="k">if</span> <span class="n">swapAccepted</span><span class="p">:</span>

                    <span class="c"># exchange likelihood</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">lnlike0</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">lnlike0</span> <span class="o">=</span> <span class="n">newlnlike</span>

                    <span class="c"># exchange parameters</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                    <span class="c"># calculate new posterior values</span>
                    <span class="n">lnprob0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">*</span> <span class="n">lnlike0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>

        <span class="c"># Return values for colder chain: 0=nothing happened; 1=swap proposed,</span>
        <span class="c"># not accepted; 2=swap proposed &amp; accepted</span>
        <span class="k">if</span> <span class="n">swapProposed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">swapAccepted</span><span class="p">:</span>
                <span class="n">swapReturn</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">swapReturn</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">swapReturn</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">swapReturn</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">lnlike0</span><span class="p">,</span> <span class="n">lnprob0</span>
</div>
<div class="viewcode-block" id="PTSampler.temperatureLadder"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.temperatureLadder">[docs]</a>    <span class="k">def</span> <span class="nf">temperatureLadder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tstep</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to compute temperature ladder. At the moment this uses</span>
<span class="sd">        a geometrically spaced temperature ladder with a temperature</span>
<span class="sd">        spacing designed to give 25 % temperature swap acceptance rate.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: make options to do other temperature ladders</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tstep</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tstep</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tstep</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">Tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tstep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Tmax</span> <span class="o">/</span> <span class="n">Tmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ladder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchain</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchain</span><span class="p">):</span>
                <span class="n">ladder</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tmin</span> <span class="o">*</span> <span class="n">tstep</span> <span class="o">**</span> <span class="n">ii</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ladder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ladder</span>
</div>
    <span class="k">def</span> <span class="nf">_writeToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to write chain file. File has 3+ndim columns,</span>
<span class="sd">        the first is log-posterior (unweighted), log-likelihood,</span>
<span class="sd">        and acceptance probability, followed by parameter values.</span>

<span class="sd">        :param iter: Iteration of sampler</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;a+&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">iter</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">isave</span><span class="p">),</span> <span class="nb">iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thin</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">jj</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">thin</span><span class="p">)</span>
            <span class="n">pt_acc</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPIrank</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchain</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">swapProposed</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pt_acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nswap_accepted</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">swapProposed</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%22.22f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chain</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">kk</span><span class="p">])</span>
                                             <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="si">%f</span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lnprob</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">_lnlike</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">naccepted</span> <span class="o">/</span>
                                                             <span class="nb">iter</span><span class="p">,</span> <span class="n">pt_acc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chainfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c"># function to update covariance matrix for jump proposals</span>
    <span class="k">def</span> <span class="nf">_updateRecursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">mem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to recursively update sample covariance matrix.</span>

<span class="sd">        :param iter: Iteration of sampler</span>
<span class="sd">        :param mem: Number of steps between updates</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span> <span class="o">-</span> <span class="n">mem</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>

        <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mem</span><span class="p">):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>

                <span class="n">diff</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span><span class="p">[</span><span class="nb">iter</span> <span class="o">-</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">/</span> <span class="n">it</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">M2</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span><span class="p">[</span><span class="nb">iter</span> <span class="o">-</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M2</span> <span class="o">/</span> <span class="p">(</span><span class="n">it</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c"># do svd on parameter groups</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">):</span>
            <span class="n">covgroup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                    <span class="n">covgroup</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">group</span><span class="p">[</span><span class="n">jj</span><span class="p">]]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">ct</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">covgroup</span><span class="p">)</span>

    <span class="c"># function to update gaussian KDE  of posterior based on current samples</span>
    <span class="k">def</span> <span class="nf">_updateKDE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update gaussian KDE of posterior using previous samples</span>

<span class="sd">        :param iter: current iteration of chain</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">burn</span><span class="p">:</span><span class="nb">iter</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">gaussian_kde</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c"># update DE buffer samples</span>
    <span class="k">def</span> <span class="nf">_updateDEbuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">burn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update Differential Evolution with last burn</span>
<span class="sd">        values in the total chain</span>

<span class="sd">        :param iter: Iteration of sampler</span>
<span class="sd">        :param burn: Total number of samples in DE buffer</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AMbuffer</span><span class="p">[</span><span class="nb">iter</span> <span class="o">-</span> <span class="n">burn</span><span class="p">:</span><span class="nb">iter</span><span class="p">]</span>

    <span class="c"># KDE jump proposal</span>
<div class="viewcode-block" id="PTSampler.KDEJumpProposal"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.KDEJumpProposal">[docs]</a>    <span class="k">def</span> <span class="nf">KDEJumpProposal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Gaussian KDE from previous chain values to propose new parameters.</span>
<span class="sd">        This does not depend on the current position in parameter space and should</span>
<span class="sd">        help reduce the ACL of the chain.</span>

<span class="sd">        :param x: Parameter vector at current position</span>
<span class="sd">        :param iter: Iteration of sampler</span>
<span class="sd">        :param beta: Inverse temperature of chain</span>

<span class="sd">        :returns: New position in parameter space</span>
<span class="sd">        :returns: Forward-Backward jump probability</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># new parameters</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c"># forward-backward jump probability</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">qxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p0</span> <span class="o">/</span> <span class="n">p1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">qxy</span>

    <span class="c"># SCAM jump</span></div>
<div class="viewcode-block" id="PTSampler.covarianceJumpProposalSCAM"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.covarianceJumpProposalSCAM">[docs]</a>    <span class="k">def</span> <span class="nf">covarianceJumpProposalSCAM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Single Component Adaptive Jump Proposal. This function will occasionally</span>
<span class="sd">        jump in more than 1 parameter. It will also occasionally use different</span>
<span class="sd">        jump sizes to ensure proper mixing.</span>

<span class="sd">        :param x: Parameter vector at current position</span>
<span class="sd">        :param iter: Iteration of sampler</span>
<span class="sd">        :param beta: Inverse temperature of chain</span>

<span class="sd">        :returns: New position in parameter space</span>
<span class="sd">        :returns: Forward-Backward jump probability</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">qxy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># choose group</span>
        <span class="n">jumpind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">))</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">jumpind</span><span class="p">])</span>

        <span class="c"># adjust step size</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>

        <span class="c"># small jump</span>
        <span class="k">if</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">0.2</span>

        <span class="c"># large jump</span>
        <span class="k">elif</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mf">0.97</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c"># small-medium jump</span>
        <span class="c"># elif prob &gt; 0.6:</span>
            <span class="c">#:wq    scale = 0.5</span>

        <span class="c"># standard medium jump</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c">#scale = np.random.uniform(0.5, 10)</span>

        <span class="c"># adjust scale based on temperature</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span>

        <span class="c"># get parmeters in new diagonalized basis</span>
        <span class="c">#y = np.dot(self.U.T, x[self.covinds])</span>

        <span class="c"># make correlated componentwise adaptive jump</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">neff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="mf">2.4</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">neff</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>

        <span class="c">#y[ind] = y[ind] + np.random.randn(neff) * cd * np.sqrt(self.S[ind])</span>
        <span class="c">#q[self.covinds] = np.dot(self.U, y)</span>
        <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">jumpind</span><span class="p">]]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span> <span class="o">*</span> <span class="n">cd</span> <span class="o">*</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">jumpind</span><span class="p">][</span><span class="n">ind</span><span class="p">])</span> <span class="o">*</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">jumpind</span><span class="p">][:,</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">qxy</span>

    <span class="c"># AM jump</span></div>
<div class="viewcode-block" id="PTSampler.covarianceJumpProposalAM"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.covarianceJumpProposalAM">[docs]</a>    <span class="k">def</span> <span class="nf">covarianceJumpProposalAM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adaptive Jump Proposal. This function will occasionally</span>
<span class="sd">        use different jump sizes to ensure proper mixing.</span>

<span class="sd">        :param x: Parameter vector at current position</span>
<span class="sd">        :param iter: Iteration of sampler</span>
<span class="sd">        :param beta: Inverse temperature of chain</span>

<span class="sd">        :returns: New position in parameter space</span>
<span class="sd">        :returns: Forward-Backward jump probability</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">qxy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># choose group</span>
        <span class="n">jumpind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">))</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">jumpind</span><span class="p">])</span>

        <span class="c"># adjust step size</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>

        <span class="c"># small jump</span>
        <span class="k">if</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">0.2</span>

        <span class="c"># large jump</span>
        <span class="k">elif</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mf">0.97</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c"># small-medium jump</span>
        <span class="c"># elif prob &gt; 0.6:</span>
        <span class="c">#    scale = 0.5</span>

        <span class="c"># standard medium jump</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c"># adjust scale based on temperature</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span>

        <span class="c"># get parmeters in new diagonalized basis</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">jumpind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">jumpind</span><span class="p">]])</span>

        <span class="c"># make correlated componentwise adaptive jump</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">jumpind</span><span class="p">]))</span>
        <span class="n">neff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="mf">2.4</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">neff</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>

        <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">neff</span><span class="p">)</span> <span class="o">*</span> <span class="n">cd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">jumpind</span><span class="p">][</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">jumpind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">jumpind</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>

        <span class="c">#cd = 2.4/np.sqrt(2*self.ndim) * np.sqrt(scale)</span>
        <span class="c">#q = np.random.multivariate_normal(x, cd**2*self.cov)</span>

        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">qxy</span>

    <span class="c"># Differential evolution jump</span></div>
<div class="viewcode-block" id="PTSampler.DEJump"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.DEJump">[docs]</a>    <span class="k">def</span> <span class="nf">DEJump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differential Evolution Jump. This function will  occasionally</span>
<span class="sd">        use different jump sizes to ensure proper mixing.</span>

<span class="sd">        :param x: Parameter vector at current position</span>
<span class="sd">        :param iter: Iteration of sampler</span>
<span class="sd">        :param beta: Inverse temperature of chain</span>

<span class="sd">        :returns: New position in parameter space</span>
<span class="sd">        :returns: Forward-Backward jump probability</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># get old parameters</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">qxy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">bufsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">alen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span><span class="p">)</span>

        <span class="c"># draw a random integer from 0 - iter</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span>

        <span class="c"># make sure mm and nn are not the same iteration</span>
        <span class="k">while</span> <span class="n">mm</span> <span class="o">==</span> <span class="n">nn</span><span class="p">:</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span>

        <span class="c"># get jump scale size</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>

        <span class="c"># mode jump</span>
        <span class="k">if</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">*</span> <span class="mf">2.4</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">beta</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>

            <span class="c"># jump size</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span><span class="p">[</span><span class="n">mm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEbuffer</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>

            <span class="c"># jump</span>
            <span class="n">q</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">sigma</span>

        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">qxy</span>

    <span class="c"># add jump proposal distribution functions</span></div>
<div class="viewcode-block" id="PTSampler.addProposalToCycle"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.addProposalToCycle">[docs]</a>    <span class="k">def</span> <span class="nf">addProposalToCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add jump proposal distributions to cycle with a given weight.</span>

<span class="sd">        :param func: jump proposal function</span>
<span class="sd">        :param weight: jump proposal function weight in cycle</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># get length of cycle so far</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span><span class="p">)</span>

        <span class="c"># check for 0 weight</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;ERROR: Can not have 0 weight in proposal cycle!&#39;</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="c"># add proposal to cycle</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="n">weight</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="c"># add auxilary jump proposal distribution functions</span></div>
<div class="viewcode-block" id="PTSampler.addAuxilaryJump"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.addAuxilaryJump">[docs]</a>    <span class="k">def</span> <span class="nf">addAuxilaryJump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add auxilary jump proposal distribution. This will be called after every</span>
<span class="sd">        standard jump proposal. Examples include cyclic boundary conditions and</span>
<span class="sd">        pulsar phase fixes</span>

<span class="sd">        :param func: jump proposal function</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># set auxilary jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux</span> <span class="o">=</span> <span class="n">func</span>

    <span class="c"># randomized proposal cycle</span></div>
<div class="viewcode-block" id="PTSampler.randomizeProposalCycle"><a class="viewcode-back" href="../PTMCMCSampler.html#PTMCMCSampler.PTSampler.randomizeProposalCycle">[docs]</a>    <span class="k">def</span> <span class="nf">randomizeProposalCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomize proposal cycle that has already been filled</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># get length of full cycle</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span><span class="p">)</span>

        <span class="c"># get random integers</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">length</span><span class="p">)</span>

        <span class="c"># randomize proposal cycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomizedPropCycle</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>

    <span class="c"># call proposal functions from cycle</span></div>
    <span class="k">def</span> <span class="nf">_jump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call Jump proposals</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># get length of cycle</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propCycle</span><span class="p">)</span>

        <span class="c"># call function</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomizedPropCycle</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span>
                <span class="nb">iter</span><span class="p">,</span> <span class="n">length</span><span class="p">)](</span>
            <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span>

        <span class="c"># axuilary jump</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">qxy_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span>
            <span class="n">qxy</span> <span class="o">+=</span> <span class="n">qxy_aux</span>

        <span class="c"># increment proposal cycle counter and re-randomize if at end of cycle</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">randomizeProposalCycle</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">qxy</span>

    <span class="c"># TODO: jump statistics</span>

</div>
<span class="k">class</span> <span class="nc">_function_wrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a hack to make the likelihood function pickleable when ``args``</span>
<span class="sd">    or ``kwargs`` are also included.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">PTMCMCSampler  documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Justin A. Ellis.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>